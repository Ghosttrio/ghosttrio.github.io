---
layout: post
title: 자바 record 클래스
categories: Java
---


자바 record 클래스는 자바 14에 처음 도입된 새로운 기능으로, 주로 불변 데이터 객체를 생성하는 데 사용된다.

record는 dto와 같이 데이터 값을 보관하는 객체를 생성할 때 유용하다.

record 사용 예시
```java
public record User(String name, int age) {

}

```

record 클래스는 일반적인 클래스와 달리 equals(), hashCode(), toString() 메서드를 제공하고 getter 메서드를 제공한다.

**여러 개발 블로그에 직렬화(Serializable)도 자동으로 구현된다고 적혀 있는 경우가 종종 있는데 record클래스는 Serializable가 자동으로 구현되어 있지 않다!!**   
[스택오버플로우](https://stackoverflow.com/questions/78980974/should-i-do-java-record-class-implement-serialization)


```java
public class Main {
    public static void main(String[] args) {
        User user = new User("ghosttrio", 30);
        
        // 자동 생성된 getter 메서드 사용
        System.out.println(user.name());  // "ghosttrio"
        System.out.println(user.age());   // 30

        // 자동 생성된 toString() 메서드 사용
        System.out.println(person);         // Person[name=ghosttrio, age=30]

        // 자동 생성된 equals() 메서드 사용
        Person userb = new Person("ghosttrio", 30);
        System.out.println(user.equals(userb));  // true

        // 자동 생성된 hashCode() 메서드 사용
        System.out.println(user.hashCode());  // 객체의 해시 코드 값
    }
}

```


### DTO 객체에 활용

dto 객체에 record 클래스를 활용하면 여러 어노테이션을 붙이거나(롬복), 여러 클래스를 만드는 등 번거로움이 줄어든다.

예를 들어, 유저 생성 request 객체를 만든다고 가정한다면 이런 식으로 만들 수 있다.

``` java
public record CreateUserRequest(String name, int age) {
}


@PostMapping
public String createUser(@RequestBody CreateUserRequest request) {
    userService.create(request.name(), request.age());
}
```

기존의 롬복이나 getter, setter를 사용한 클래스 dto보다는 좀 더 깔끔한 형태로 만들 수 있다.

아니면 클래스에 여러 record 객체를 포함하여 좀 더 컴팩트하게 만들 수도 있다.
``` java
public class UserRequest {
    public record Create(String name, int age) {
    }
    public record Update(int age) {
    }
    public record Delete(String name) {
    }
}


@PostMapping
public String createUser(@RequestBody UserRequest.Create request) {
    userService.create(request.name(), request.age());
}
```

이런 식으로 특정 도메인의 Request 객체를 통합하여 한 번에 관리할 수 있다.

### 커스텀 메서드 사용
레코드 객체는 커스텀 메서드를 사용할 수 있다.

주로 개발할 때 dto 객체를 다른 dto로 변환하거나 할 때 사용한다.

예를 들어, presentation 계층과 application 계층의 구분을 두고, 각각의 dto를 사용하고자 할 때 사용한다.


``` java
public record CreateUserRequest(String name, int age) {

    // application에서만 사용할 객체 리턴
    public CreateUserServiceRequest toService() {
        return new CreateUserServiceRequest(name, age);
    }

}

@PostMapping
public String createUser(@RequestBody CreateUserRequest request) {
    userService.create(request.toService());
}
```

### @ConfigurationProperties

record 클래스를 사용하면 기존 properties 관리를 좀 더 효율적으로 할 수 있다.

```java
@ConfigurationProperties("test")
public record TestProperties(
	TestA testa
	TestB testb
) {
	public record TestA(
    	String a,
        String b
    ) { }
    
    public record TestB(
    	String c,
        String d
    ) { }
}
```

### JPA Entitiy?
record 객체를 써먹기에 딱 좋아 보이는 곳이 JPA 엔티티이다.

하지만 record 클래스는 엔티티 클래스로 사용하지 못하는데, 이유는 다음과 같다.

1. record 객체는 불변 객체이기 때문에 JPA 영속성 컨텍스트에서 객체의 상태를 추적하고 변경할 수 있어야 한다. 하지만 record 불변이기 때문에 해당 작업을 수행하지 못한다.

2. JPA 엔티티 클래스는 기본 생성자가 있어야 한다. 엔티티를 인스턴스화할 때 기본 생성자를 사용하며, 그 후에 필드를 채우거나 setter 메서드를 사용하여 값을 설정한다. 반면에, record 클래스는 자동 생성된 생성자만 제공한다. 이 생성자는 매개변수화된 생성자로, 기본 생성자를 제공하지 않는다. 따라서 문제가 발생한다. 

3. 쿼리 결과 처리 후 수행할 getter가 명명 규칙을 따르지 않는다. 예를 들어, getName()이 아니라, name()이다.