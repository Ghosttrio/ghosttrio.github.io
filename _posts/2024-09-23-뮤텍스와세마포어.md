---
layout: post
title: Mutex와 Semaphore
categories: Backend
---

뮤텍스(Mutex)와 세마포어(Semaphore)에 대해서 알아보자.

### 뮤텍스(Mutex)
뮤텍스는 상호 배제를 보장하는 잠금 메커니즘이다.   

하나의 자원에 대해 한 번에 하나의 스레드만 접근할 수 있도록 하는 방식이다.   

즉, 뮤텍스를 사용하면 동시성 문제를 방지하고 레이스 컨디션을 막을 수 있다. 

[스택오버플로우](https://stackoverflow.com/questions/34524/what-is-a-mutex)에 재밌는 예시가 있어서 가져와봤다!

> 예를 들어, 사무실에서 격한 토론을 할 때에 테이블에 장난감 닭을 집은 사람만
> 발언권을 얻고 나머지는 말을 하지 못한다고 가정해보자.
>
> 닭을 집은 사람이 말을 할 때엔 다른 사람들은 닭을 받을 때까지 기다렸다가 말을 할 수 있다. 
>
> 말을 마치면 닭을 사회자에게 돌려주고 사회자는 다음 사람에게 닭을 전달한다.
>
> 여기서 닭을 Mutex로, 사람을 Thread로 바꾸면 Mutex라는 개념이 생긴다. 

뮤텍스의 개념을 자바 코드로 알아보자.

synchronized 키워드는 자바에서 기본적인 뮤텍스 기능을 제공한다.

특정 블록이나 메서드에 대해 동기화를 하여 한 번에 하나의 스레드만 접근할 수 있게 해준다.

``` java

public class MutexTest {
    static class Mutex {
        private int counter = 0;

        public synchronized void increment() {
            counter++;
        }

        public synchronized int getCounter() {
            return counter;
        }
    }
    @Test
    void mutexCounterTest() throws InterruptedException {
        Mutex mutex = new Mutex();

        Thread threadA = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                mutex.increment();
            }
        });

        Thread threadB = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                mutex.increment();
            }
        });

        threadA.start();
        threadB.start();

        threadA.join();
        threadB.join();

        assertEquals(20000, mutex.getCounter()); // 테스트 성공
    }
}


```

해당 테스트 코드를 실행하면 테스트가 성공하는 것을 볼 수 있다. 

만약에 synchronized 키워드를 지우면 어떻게 될까?

``` java

public class MutexTest {
    static class Mutex {
        private int counter = 0;

        public void increment() {
            counter++;
        }

        public int getCounter() {
            return counter;
        }
    }
    @Test
    void mutexCounterTest() throws InterruptedException {
        Mutex mutex = new Mutex();

        Thread threadA = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                mutex.increment();
            }
        });

        Thread threadB = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                mutex.increment();
            }
        });

        threadA.start();
        threadB.start();

        threadA.join();
        threadB.join();

        assertEquals(20000, mutex.getCounter()); // 테스트 실패
    }
}


// 결과
Expected :20000
Actual   :14831

```

테스트 숫자의 크기가 작으면 성공할 때도 있지만 동시성 문제가 발생하여 대부분 실패한다. 

사람들이 서로 닭을 집어가는 상황인 것이다.

뮤텍스는 단일 자원에 대한 동시 접근을 방지하는 데 사용된다. 

하지만 같은 스레드만 잠금을 해제할 수 있기 때문에, 잘못된 잠금 해제가 발생하면 데드락(교착상태)이 발생할 수 있다.

### 세마포어(Semaphore)
세마포어는 카운팅 기반의 동기화 기법으로, 여러 스레드나 프로세스가 동시에 접근할 수 있는 자원의 개수를 제한할 때 사용된다. 

세마포어는 정수 값을 유지하며, 이 값은 자원에 접근 가능한 수를 나타낸다.

세마포어는 [도서관에 비유]https://en.wikipedia.org/wiki/Semaphore_(programming))해보자.

>도서관에 스터디 룸이 10개가 있다고 가정하고, 한 번에 한 명의 학생이 사용할 수 있다고 가정하자.
>
>학생들은 접수 데스크에서 스터디 룸을 요청해야 한다.
>
>빈 스터디 룸이 없다면 학생들은 다른 학생이 룸을 내어줄 때까지 접수 데스크에서 기다려야 한다.
>
>학생이 룸 사용을 마치면 학생은 데스크로 돌아와서 룸이 비어 있음을 알려야 한다.

세마포어는 자원의 개수를 제한하여 동시성을 제어하는 방법이다.

세마포어도 자바 코드로 알아보자.

자바에서 세마포어는 java.util.concurrent 패키지에 포함된 Semaphore 클래스로 제공된다.
- acquire(): 세마포어의 카운트를 하나 감소시키며, 카운트가 0이면 대기합니다.
- release(): 세마포어의 카운트를 하나 증가시킵니다.

```java

public class SemaphoreTest {

    private static final Semaphore semaphore = new Semaphore(3);

    public void accessResource(int threadId) {
        try {
            semaphore.acquire();
            Thread.sleep(1000);
            System.out.println("ID : " + threadId + " 세마포어 얻음");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            semaphore.release();
            System.out.println("ID : " + threadId + " 세마포어 반납");
        }
    }

    @Test
    public void testSemaphore() throws InterruptedException {
        // 최대 3개의 스레드만 자원에 접근할 수 있도록 설정

        // 스레드를 동시에 실행시키기 위한 ExecutorService
        ExecutorService executorService = Executors.newFixedThreadPool(5); // 5개의 스레드를 생성

        // 5개의 스레드를 실행하여 자원에 접근 시도
        for (int i = 1; i <= 5; i++) {
            final int threadId = i;
            executorService.submit(() -> accessResource(threadId));
        }

        // 모든 작업이 끝날 때까지 기다림
        executorService.shutdown();
        while (!executorService.isTerminated()) {
            Thread.sleep(100); // 대기
        }

    }
}

// 결과
ID : 3 세마포어 얻음
ID : 2 세마포어 얻음
ID : 3 세마포어 반납
ID : 1 세마포어 얻음
ID : 1 세마포어 반납
ID : 2 세마포어 반납
ID : 4 세마포어 얻음
ID : 4 세마포어 반납
ID : 5 세마포어 얻음
ID : 5 세마포어 반납

```

여러 번 실행해봐도 연속으로 3번 이상 세마포어를 얻는 로그는 발견되지 않는다.